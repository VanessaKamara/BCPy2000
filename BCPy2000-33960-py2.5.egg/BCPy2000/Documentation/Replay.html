<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>BCPy2000: Replay</title>
<link type="text/css" rel="stylesheet" href="styles/gears/style.css" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
<div class="header"><span class="gotobar bar"><a class="local" href="Home.html">Home</a> <a class="local" href="About.html">About</a> <a class="local" href="Download.html">Download</a> <a class="local" href="Structure.html">Structure</a> <a class="local" href="Demo.html">Demo</a> <a class="local" href="Hooks.html">Hooks</a> <a class="local" href="API.html">API</a> <a class="local" href="Contact.html">Contact</a> <a class="local" href="Credits.html">Credits</a> <a class="local" href="License.html">License</a> </span><h1>Replay</h1></div><div class="content"><p>Replay mode or "slave" mode is enabled, for BCPy2000 modules, by checking the <code>EnslavePython</code> checkbox in the <code>Source</code> config tab. It ensures that the BCPy2000 signal-processing and application modules cannot change the state variables and must simply obey whatever values are passed from earlier in the chain. A slave-mode-aware source module can take advantage of this.</p><p>One of our <a class="local canonical" title="Tools" href="Tools.html">tools</a>, the "playback" source module, is an example of such a source module. It is invoked by passing </p><pre class="real">--PythonSrcClassFile=BCI2000Tools/PlaybackSourceModule.py
</pre><p>among the <a class="local canonical" title="Command-line_Options" href="Command-line_Options.html">command-line options</a> to the <a class="local canonical" title="Signal_Source_Binary" href="Signal_Source_Binary.html">signal source binary</a>. It allows you to play back signals from a BCI2000 <code>.dat</code> file, specified in the <code>PlaybackFileName</code> parameter in the <code>Source</code> tab  (NB: you should ensure that your <code>SamplingRate</code> and <code>SourceCh</code> parameters match those of the file you're playing back, otherwise the source module will issue an error). Even without turning on slave mode, this can useful for development, since it allows your signal-processing module to work with the statistics of real biosignals without having to wire somebody up for the occasion. It can also be useful in debugging, if you use the source module's <a class="local canonical" title="Shell" href="Shell.html">shell</a> to issue the commands <code>self.stop()</code>, <code>self.step()</code> and <code>self.cont()</code>.</p><p>Optionally, you can choose to make the playback source module play back the state variables as well as the signals, by enabling <code>EnslavePython</code>. Note that playing back an existing file in slave mode does not necessarily guarantee that you'll see exactly the same results as the first time around. For this to happen, the following criteria must be met:</p><ul><li>Your <code>SampleBlockSize</code> should be the same as the original -- otherwise, since only one state variable value can be transmitted through the system per sample block, there is a danger of aliasing in the state values.</li><li>Your python application code must, obviously, be unchanged, and must also be deterministic for given state variable values. In particular, the <a class="local canonical" title="Phase_Machine" href="Phase_Machine.html">phase machine</a> (defined by <code>self.Phases</code>) must be specified <strong>exactly</strong> the same as before: the <code>self.phase</code> calls must be made in the same order as before, to ensure the same mapping as before between phase ids (integer values of the <code>PresentationPhase</code> state variable) and the string phase names that get passed to the <code>self.Transition</code> hook.</li><li>If the signal processing output affects the application's behaviour, then the signal processing code must also be unchanged, and it must also be either fully deterministic (if non-python), or deterministic for given state variable values (if BCPy2000).</li></ul><p>It's worth clarifying what is meant by "deterministic for given state variable values." Slave mode is realized by silently preventing the BCPy2000 signal-processing and application modules from changing <code>self.states</code>. As an example, let's assume you have defined a state variable called <code>target</code>, a phase called <code>cue</code> during which an auditory cue stimulus is presented, and, during your <code>Initialize</code> hook, you have pre-loaded a <code>pygame.mixer.Sound</code> object for each cue and stored them in a <code>list</code> at <code>self.my_cue_wavs</code>. The following code will then ensure exact replayability: </p><pre class="real">    def Transition(self, phase):
        if phase == 'cue':
            self.states['target'] = random.randint(1,2)
            t = self.states['target']
            self.my_cue_wavs[t-1].play()
</pre><p>because <code>self.states</code> is not modifiable in slave mode. The following code, by contrast, achieves identical results when used "live", but might play a different sequence of auditory stimuli when replayed: </p><pre class="real">    def Transition(self, phase):
        if phase == 'cue':
            t = random.randint(1,2)
            self.states['target'] = t
            self.my_cue_wavs[t-1].play()
</pre><p>Random numbers in the phase durations (for example, a randomized intertrial interval length) are fine: the replayed <code>PresentationPhase</code> state variable will determine when phase transitions occur, rather than the phase machine itself.</p><p>Finally, although playback mode is very useful during the development cycle of a BCI system, it is worth making the following caveat: if you record some EEG data, learn classification parameters from it, slot those parameters into the config and replay the file, performance will probably be very good. Don't celebrate too soon (and please don't publish yet). Performance nearly always <strong>is</strong> very good when it's assessed on exactly the same data that you've just trained on. Performance on <strong>new</strong> data, which the parameter estimation procedure has not yet seen, is what counts.</p><p>So far so obvious, we hope. But note that the same principle applies, in perhaps a slightly less obvious manner, to cross-validation. If you train your classifier on file A and test it on file B, that's fine. However, you might then decide to go back, tweak the classification method, re-apply it to A and re-test it on B. Your tweaking-and-retesting has now become part of the learning procedure, and now B is "seen" (to more or less of an extent, depending on how much tweaking room you allowed yourself). So you can't report a truly honest assessment of your approach by reporting the performance-on-B of the classification approach that you have now found to perform best-on-B. To assess your method properly, you have to finish the A-B iteration, fix all possible learning parameters (including those optimized "by eye"), and test on <strong>new</strong> data C, D, E...</p><p>This message was brought to you by Machine-Learners' Mothers Against Overfitting.</p></div><div class="footer"><hr /> <span class="gotobar bar"><a class="local" href="Home.html">Home</a> <a class="local" href="About.html">About</a> <a class="local" href="Download.html">Download</a> <a class="local" href="Structure.html">Structure</a> <a class="local" href="Demo.html">Demo</a> <a class="local" href="Hooks.html">Hooks</a> <a class="local" href="API.html">API</a> <a class="local" href="Contact.html">Contact</a> <a class="local" href="Credits.html">Credits</a> <a class="local" href="License.html">License</a> </span> <span class="edit"></span> <span class="time"><span class="time"><br /> Last edited 2008-08-19 22:48 UTC by <a class="author" title="from localhost" href="jez.html">jez</a> <a class="diff">(diff)</a></span></span></div></body></html>